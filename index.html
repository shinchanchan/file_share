<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>PeerJS File Transfer</title>

<script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>

<style>
body { 
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif; 
    padding: 20px; 
    max-width: 800px; 
    margin: 0 auto; 
    background: #f5f5f5;
}
.container { 
    background: white; 
    padding: 25px; 
    border-radius: 10px; 
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
}
h2 { 
    color: #333; 
    text-align: center; 
    margin-bottom: 25px;
}
.box { 
    border: 1px solid #ddd; 
    padding: 20px; 
    margin: 15px 0; 
    border-radius: 8px;
    background: #fafafa;
}
input, button { 
    width: 100%; 
    padding: 12px; 
    margin: 8px 0; 
    box-sizing: border-box;
    border: 1px solid #ddd;
    border-radius: 6px;
    font-size: 16px;
}
input:focus, button:focus {
    outline: none;
    border-color: #4CAF50;
}
button {
    background: #4CAF50;
    color: white;
    border: none;
    cursor: pointer;
    font-weight: bold;
    transition: background 0.3s;
}
button:hover {
    background: #45a049;
}
button:disabled {
    background: #cccccc;
    cursor: not-allowed;
}
input[type="file"] {
    padding: 10px;
    border: 2px dashed #ddd;
    background: white;
}
input[type="file"]:hover {
    border-color: #4CAF50;
}
progress {
    width: 100%;
    height: 25px;
    -webkit-appearance: none;
    appearance: none;
    border-radius: 5px;
    overflow: hidden;
}
progress::-webkit-progress-bar {
    background-color: #eee;
    border-radius: 5px;
}
progress::-webkit-progress-value {
    background: linear-gradient(45deg, #4CAF50, #45a049);
    border-radius: 5px;
}
progress::-moz-progress-bar {
    background: linear-gradient(45deg, #4CAF50, #45a049);
    border-radius: 5px;
}
#status {
    padding: 15px;
    border-radius: 5px;
    margin: 15px 0;
    min-height: 20px;
    font-weight: bold;
    text-align: center;
}
#myId {
    background: #e8f5e9;
    padding: 15px;
    border-radius: 5px;
    text-align: center;
    font-family: monospace;
    font-size: 20px;
    color: #2e7d32;
    word-break: break-all;
    margin: 10px 0;
}
.copy-btn {
    background: #2196F3;
    width: auto;
    padding: 8px 15px;
    margin: 5px;
    display: inline-block;
}
.copy-btn:hover {
    background: #1976D2;
}
.instructions {
    background: #e3f2fd;
    padding: 15px;
    border-radius: 5px;
    margin: 15px 0;
    font-size: 14px;
}
.instructions ol {
    margin: 10px 0;
    padding-left: 20px;
}
.device-list {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    justify-content: center;
    margin: 15px 0;
}
.device-icon {
    background: #f0f0f0;
    padding: 10px 15px;
    border-radius: 20px;
    font-size: 14px;
    color: #666;
}
.connection-status {
    display: flex;
    align-items: center;
    gap: 10px;
    margin: 10px 0;
}
.status-indicator {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    background: #ccc;
}
.status-indicator.connected { background: #4CAF50; }
.status-indicator.connecting { background: #FFC107; animation: pulse 1.5s infinite; }
.status-indicator.disconnected { background: #F44336; }
@keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
}
@media (max-width: 600px) {
    body {
        padding: 10px;
    }
    .container {
        padding: 15px;
    }
    .box {
        padding: 15px;
    }
    input, button {
        padding: 10px;
    }
}
</style>
</head>

<body>

<div class="container">
    <h2>üåê Cross-Platform File Transfer</h2>
    
    <div class="device-list">
        <span class="device-icon">üì± iPhone</span>
        <span class="device-icon">ü§ñ Android</span>
        <span class="device-icon">üíª Windows</span>
        <span class="device-icon">üêß Linux/Ubuntu</span>
        <span class="device-icon">üçé Mac</span>
    </div>
    
    <div class="connection-status">
        <div class="status-indicator" id="connectionStatus"></div>
        <span id="connectionText">Connecting to signaling server...</span>
    </div>
    
    <div class="box">
        <b>Your Peer ID:</b>
        <div id="myId">Generating...</div>
        <button class="copy-btn" onclick="copyMyId()">üìã Copy My ID</button>
        <button class="copy-btn" onclick="generateNewId()">üîÑ New ID</button>
    </div>
    
    <div class="instructions">
        <b>How to use:</b>
        <ol>
            <li>Share your Peer ID with the receiver</li>
            <li>Enter receiver's Peer ID</li>
            <li>Select file and click "Send File"</li>
            <li>Receiver will get automatic download</li>
        </ol>
        <p style="margin-top: 10px; font-style: italic;">
            <small>Note: Both devices need to be online and have WebRTC support. For best results, try on same WiFi network.</small>
        </p>
    </div>
    
    <div class="box">
        <input id="remoteId" placeholder="üì® Enter Receiver's Peer ID">
        <input type="file" id="fileInput">
        <button onclick="sendFile()" id="sendBtn">üì§ Send File</button>
        <button onclick="disconnect()" id="disconnectBtn" style="background: #f44336; margin-top: 5px;">Disconnect</button>
    </div>
    
    <div class="box">
        <b>Transfer Progress:</b>
        <progress id="progress" value="0" max="100"></progress>
        <div id="status">Waiting for connection...</div>
        <div id="fileInfo"></div>
    </div>
</div>

<script>
const CHUNK_SIZE = 16 * 1024; // Reduced for better compatibility
let receivedChunks = [];
let receivedSize = 0;
let fileMeta = null;
let currentConn = null;
let isSending = false;
let peer = null;

// Generate a simple peer ID
function generateId() {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    let result = '';
    for (let i = 0; i < 8; i++) {
        result += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return "peer-" + result;
}

// Update connection status indicator
function updateConnectionStatus(status, text) {
    const indicator = document.getElementById('connectionStatus');
    const textElem = document.getElementById('connectionText');
    
    indicator.className = 'status-indicator ' + status;
    textElem.textContent = text;
}

// Initialize PeerJS connection
function initializePeer(peerId = null) {
    if (peer) {
        peer.destroy();
    }
    
    const peerIdToUse = peerId || generateId();
    
    peer = new Peer(peerIdToUse, {
        host: '0.peerjs.com',
        port: 443,
        path: '/',
        secure: true,
        debug: 0,
        config: {
            iceServers: [
                // Public STUN servers
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' },
                { urls: 'stun:stun3.l.google.com:19302' },
                { urls: 'stun:stun4.l.google.com:19302' },
                
                // Twilio STUN (without transport parameter in URL)
                { urls: 'stun:global.stun.twilio.com:3478' },
                
                // Free TURN servers (may have limits)
                { 
                    urls: 'turn:numb.viagenie.ca',
                    credential: 'muazkh',
                    username: 'webrtc@live.com'
                },
                { 
                    urls: 'turn:openrelay.metered.ca:80',
                    credential: 'openrelayproject',
                    username: 'openrelayproject'
                },
                { 
                    urls: 'turn:openrelay.metered.ca:443',
                    credential: 'openrelayproject',
                    username: 'openrelayproject'
                },
                { 
                    urls: 'turn:openrelay.metered.ca:443?transport=tcp',
                    credential: 'openrelayproject',
                    username: 'openrelayproject'
                }
            ],
            iceCandidatePoolSize: 10,
            iceTransportPolicy: 'all',
            rtcpMuxPolicy: 'require'
        }
    });

    peer.on('open', id => {
        document.getElementById('myId').innerText = id;
        updateConnectionStatus('connected', 'Connected! Your ID: ' + id);
        updateStatus('Ready to send/receive files', 'success');
        
        // Store ID in localStorage
        localStorage.setItem('peerjs_last_id', id);
    });

    peer.on('error', err => {
        console.error('PeerJS error:', err);
        updateConnectionStatus('disconnected', 'Connection error');
        
        if (err.type === 'unavailable-id') {
            updateStatus('ID already taken. Generating new one...', 'warning');
            setTimeout(() => generateNewId(), 1000);
        } else if (err.type === 'peer-unavailable') {
            updateStatus('Receiver not found. Check the Peer ID', 'error');
        } else {
            updateStatus('Error: ' + err.type, 'error');
        }
    });

    peer.on('disconnected', () => {
        updateConnectionStatus('disconnected', 'Disconnected');
        updateStatus('Disconnected from server. Reconnecting...', 'warning');
        setTimeout(() => {
            if (peer && peer.disconnected) {
                peer.reconnect();
            }
        }, 2000);
    });

    peer.on('close', () => {
        updateConnectionStatus('disconnected', 'Connection closed');
        updateStatus('Connection closed', 'warning');
    });

    /* ---------------- RECEIVE ---------------- */
    peer.on('connection', conn => {
        updateStatus('Incoming connection request...', 'info');
        
        conn.on('open', () => {
            updateStatus('Connected to sender', 'success');
            updateConnectionStatus('connected', 'Connected to peer');
            currentConn = conn;
        });

        conn.on('data', data => {
            console.log('Received data type:', data.type);
            
            if (data.type === 'meta') {
                fileMeta = data;
                receivedChunks = [];
                receivedSize = 0;
                updateStatus(`Receiving: ${data.name} (${formatBytes(data.size)})`, 'info');
                document.getElementById('fileInfo').innerHTML = 
                    `<b>File:</b> ${data.name}<br>
                     <b>Size:</b> ${formatBytes(data.size)}<br>
                     <b>Type:</b> ${data.mime || 'Unknown'}`;
                
                // Reset progress bar
                document.getElementById('progress').value = 0;
            }

            if (data.type === 'chunk') {
                receivedChunks.push(data.chunk);
                receivedSize += data.chunk.byteLength || data.chunk.length || 0;
                
                const progress = Math.floor((receivedSize / fileMeta.size) * 100);
                document.getElementById('progress').value = progress;
                
                updateStatus(`Downloading: ${progress}% (${formatBytes(receivedSize)}/${formatBytes(fileMeta.size)})`, 'info');
            }

            if (data.type === 'end') {
                try {
                    const blob = new Blob(receivedChunks, { type: fileMeta.mime || 'application/octet-stream' });
                    const url = URL.createObjectURL(blob);
                    
                    // For mobile/Safari compatibility
                    if (isMobile() || isSafari()) {
                        // Open in new tab for iOS/Safari
                        const newWindow = window.open(url, '_blank');
                        if (!newWindow) {
                            // If popup blocked, create download link
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = fileMeta.name;
                            a.style.display = 'none';
                            document.body.appendChild(a);
                            a.click();
                            document.body.removeChild(a);
                        }
                        updateStatus('File ready! Check new tab or downloads.', 'success');
                    } else {
                        // Normal download for other browsers
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = fileMeta.name;
                        a.style.display = 'none';
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        updateStatus('Download complete! File saved.', 'success');
                    }
                    
                    URL.revokeObjectURL(url);
                    
                    // Reset progress after delay
                    setTimeout(() => {
                        document.getElementById('progress').value = 0;
                        document.getElementById('fileInfo').innerHTML = '';
                    }, 3000);
                    
                } catch (error) {
                    console.error('Download error:', error);
                    updateStatus('Download error: ' + error.message, 'error');
                }
            }
        });

        conn.on('error', err => {
            console.error('Connection error:', err);
            updateStatus('Connection error: ' + err, 'error');
        });

        conn.on('close', () => {
            updateStatus('Connection closed', 'warning');
            currentConn = null;
            updateConnectionStatus('disconnected', 'Ready for new connection');
        });
    });
}

/* ---------------- SEND ---------------- */
function sendFile() {
    if (isSending) {
        updateStatus('Already sending a file!', 'warning');
        return;
    }
    
    const remoteId = document.getElementById('remoteId').value.trim();
    const file = document.getElementById('fileInput').files[0];
    const sendBtn = document.getElementById('sendBtn');

    if (!remoteId) {
        alert("‚ö†Ô∏è Please enter a Peer ID");
        return;
    }
    
    if (!file) {
        alert("‚ö†Ô∏è Please select a file");
        return;
    }

    if (file.size > 500 * 1024 * 1024) { // 500MB limit
        alert("‚ö†Ô∏è File too large! Maximum size is 500MB");
        return;
    }

    isSending = true;
    sendBtn.disabled = true;
    sendBtn.innerHTML = '‚è≥ Sending...';
    
    // Reset progress
    document.getElementById('progress').value = 0;
    document.getElementById('fileInfo').innerHTML = 
        `<b>File:</b> ${file.name}<br>
         <b>Size:</b> ${formatBytes(file.size)}`;

    try {
        const conn = peer.connect(remoteId, {
            reliable: true,
            serialization: 'json',
            metadata: {
                filename: file.name,
                filesize: file.size
            }
        });

        conn.on('open', () => {
            updateStatus('Connected to receiver, sending file...', 'info');
            updateConnectionStatus('connected', 'Sending file to ' + remoteId);
            
            // Send file metadata
            conn.send({ 
                type: 'meta', 
                name: file.name, 
                size: file.size,
                mime: file.type || 'application/octet-stream',
                lastModified: file.lastModified
            });

            let offset = 0;
            const totalChunks = Math.ceil(file.size / CHUNK_SIZE);
            let chunkIndex = 0;

            function sendNextChunk() {
                if (offset >= file.size) {
                    // All chunks sent
                    setTimeout(() => {
                        conn.send({ type: 'end' });
                        updateStatus('File sent successfully!', 'success');
                        sendBtn.disabled = false;
                        sendBtn.innerHTML = 'üì§ Send File';
                        isSending = false;
                        
                        // Reset progress after delay
                        setTimeout(() => {
                            document.getElementById('progress').value = 0;
                            document.getElementById('fileInfo').innerHTML = '';
                        }, 3000);
                    }, 100);
                    return;
                }

                const chunk = file.slice(offset, offset + CHUNK_SIZE);
                const reader = new FileReader();

                reader.onload = function(e) {
                    try {
                        conn.send({ 
                            type: 'chunk', 
                            chunk: e.target.result,
                            index: chunkIndex,
                            total: totalChunks
                        });
                        
                        offset += CHUNK_SIZE;
                        chunkIndex++;
                        
                        const progress = Math.min(100, Math.floor((offset / file.size) * 100));
                        document.getElementById('progress').value = progress;
                        
                        updateStatus(`Sending: ${progress}% (${formatBytes(offset)}/${formatBytes(file.size)})`, 'info');
                        
                        // Small delay to prevent overwhelming the connection
                        setTimeout(sendNextChunk, 0);
                        
                    } catch (error) {
                        console.error('Send error:', error);
                        updateStatus('Send error: ' + error.message, 'error');
                        sendBtn.disabled = false;
                        sendBtn.innerHTML = 'üì§ Send File';
                        isSending = false;
                    }
                };

                reader.onerror = function() {
                    updateStatus('Error reading file chunk', 'error');
                    sendBtn.disabled = false;
                    sendBtn.innerHTML = 'üì§ Send File';
                    isSending = false;
                };

                reader.readAsArrayBuffer(chunk);
            }

            // Start sending chunks
            setTimeout(sendNextChunk, 100);
        });

        conn.on('error', err => {
            console.error('Connection error:', err);
            updateStatus('Connection failed: ' + err.type, 'error');
            sendBtn.disabled = false;
            sendBtn.innerHTML = 'üì§ Send File';
            isSending = false;
        });

        conn.on('close', () => {
            updateStatus('Connection closed', 'warning');
            sendBtn.disabled = false;
            sendBtn.innerHTML = 'üì§ Send File';
            isSending = false;
            updateConnectionStatus('disconnected', 'Ready for new connection');
        });

    } catch (error) {
        console.error('Send file error:', error);
        updateStatus('Error: ' + error.message, 'error');
        sendBtn.disabled = false;
        sendBtn.innerHTML = 'üì§ Send File';
        isSending = false;
    }
}

/* ---------------- UTILITY FUNCTIONS ---------------- */
function updateStatus(message, type = 'info') {
    const statusElem = document.getElementById('status');
    statusElem.textContent = message;
    
    // Reset classes
    statusElem.className = '';
    
    // Add type-based styling
    switch(type) {
        case 'success':
            statusElem.style.color = '#2e7d32';
            statusElem.style.backgroundColor = '#e8f5e9';
            break;
        case 'error':
            statusElem.style.color = '#c62828';
            statusElem.style.backgroundColor = '#ffebee';
            break;
        case 'warning':
            statusElem.style.color = '#f57c00';
            statusElem.style.backgroundColor = '#fff3e0';
            break;
        default:
            statusElem.style.color = '#1565c0';
            statusElem.style.backgroundColor = '#e3f2fd';
    }
}

function formatBytes(bytes, decimals = 2) {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const dm = decimals < 0 ? 0 : decimals;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
}

function copyMyId() {
    const myId = document.getElementById('myId').textContent;
    if (navigator.clipboard) {
        navigator.clipboard.writeText(myId).then(() => {
            updateStatus('Peer ID copied to clipboard!', 'success');
        }).catch(err => {
            fallbackCopy(myId);
        });
    } else {
        fallbackCopy(myId);
    }
}

function fallbackCopy(text) {
    const textArea = document.createElement('textarea');
    textArea.value = text;
    textArea.style.position = 'fixed';
    textArea.style.opacity = '0';
    document.body.appendChild(textArea);
    textArea.select();
    try {
        document.execCommand('copy');
        updateStatus('Peer ID copied!', 'success');
    } catch (err) {
        updateStatus('Failed to copy: ' + err, 'error');
    }
    document.body.removeChild(textArea);
}

function generateNewId() {
    if (confirm('Generate new Peer ID? Current connections will be lost.')) {
        initializePeer();
    }
}

function disconnect() {
    if (currentConn) {
        currentConn.close();
        currentConn = null;
    }
    updateStatus('Disconnected from peer', 'warning');
    updateConnectionStatus('disconnected', 'Ready for new connection');
}

function isMobile() {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
}

function isSafari() {
    return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
}

// Prevent accidental page close during transfer
window.addEventListener('beforeunload', (e) => {
    if (isSending) {
        e.preventDefault();
        e.returnValue = 'File transfer in progress. Are you sure you want to leave?';
        return e.returnValue;
    }
});

// Check browser compatibility
window.addEventListener('load', () => {
    // Test for WebRTC support
    if (!navigator.mediaDevices || !window.RTCPeerConnection) {
        updateStatus('WebRTC not supported in this browser. Please use Chrome, Firefox, Edge, or Safari 11+', 'error');
        updateConnectionStatus('disconnected', 'WebRTC not supported');
        return;
    }
    
    // Initialize with saved ID or new one
    const savedId = localStorage.getItem('peerjs_last_id');
    if (savedId && confirm('Use previous Peer ID: ' + savedId + '?')) {
        initializePeer(savedId);
    } else {
        initializePeer();
    }
    
    // Update file input label
    const fileInput = document.getElementById('fileInput');
    fileInput.addEventListener('change', function() {
        if (this.files[0]) {
            updateStatus(`Selected: ${this.files[0].name} (${formatBytes(this.files[0].size)})`, 'info');
        }
    });
});
</script>

</body>
</html>
